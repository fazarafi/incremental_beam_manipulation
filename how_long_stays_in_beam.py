import re
import matplotlib.pyplot as plt

from utils import get_true_sents

bs_line_re = re.compile("BEAM SEARCH STEP \d+")
path_re = re.compile("-\d\.\d+	<GO> (?P<sent>.+)\n")


def sent_is_sub_sent(truth, sent):
    # if sent.split("<STOP>")[0].strip(" ") == truth:
    #     return True
    # else:
    return truth.startswith(sent + " ")


def how_far_true_get_through_beam(pred, true):
    truth = " ".join(true)
    for i, beam in enumerate(pred):
        if i > len(true):
            x = 1
        if not any([sent_is_sub_sent(truth, path) for path in beam]):
            # print(i)
            # print(truth)
            # print(beam)
            for sent in pred[i - 1]:
                if sent_is_sub_sent(truth, sent):
                    # print(sent)
                    pass
            # print()
            return i
    return len(pred)


def get_beam_vals(beam_size):
    debug_stream = open("output_files/debug_files/output_gen_{}.txt".format(beam_size), "r")
    results = []
    beam_vals = []
    sents_for_given_beam = []
    for line in debug_stream:
        if bs_line_re.search(line):
            beam_num = int(line.strip('\n').split(" ")[-1])
            if beam_num == 0:
                if sents_for_given_beam:
                    beam_vals.append(sents_for_given_beam)
                if beam_vals:
                    results.append(beam_vals)
                beam_vals = []
            elif sents_for_given_beam:
                beam_vals.append(sents_for_given_beam)
            sents_for_given_beam = []
        match = path_re.match(line)
        if match:
            sent = match.groupdict()['sent']
            sents_for_given_beam.append(sent)
    if sents_for_given_beam:
        beam_vals.append(sents_for_given_beam)
    if beam_vals:
        results.append(beam_vals)
    return results


def read_logs():
    for beam_size in [3, 5, 10, 30, 100]:
        results = get_beam_vals(beam_size)
        true_sents = get_true_sents()
        drop_out_info_first = []
        drop_out_info_all = []
        for pred, trues in zip(results, true_sents):
            true = trues[0]
            lost_beam = how_far_true_get_through_beam(pred, true)
            drop_out_info_first.append((lost_beam, len(true)))
            for true in trues[1:]:
                lost_beam = max(lost_beam, how_far_true_get_through_beam(pred, true))
            drop_out_info_all.append((lost_beam, len(true)))
            # print(lost_beam, len(pred), lost_beam / len(pred))
        first_average = sum([x[0] / x[1] for x in drop_out_info_first]) / len(drop_out_info_first)
        all_average = sum([x[0] / x[1] for x in drop_out_info_all]) / len(drop_out_info_all)
        plt.scatter([x[1] for x in drop_out_info_first], [x[0] for x in drop_out_info_first], alpha=0.25)
        plt.title(beam_size)
        plt.plot([0, max(x[1] for x in drop_out_info_first)], [0, max(x[1] for x in drop_out_info_first)], 'k-',
                 color='red')
        plt.xlabel("Length of true reference")
        plt.ylabel("How many correct tokens generated by beam search")
        plt.show()
        print(beam_size, first_average, all_average)


if __name__ == "__main__":
    read_logs()
